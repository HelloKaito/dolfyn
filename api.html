
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>The DOLfYN API &#8212; DOLfYN 0.12 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/js/versionwarning.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="dolfyn.Velocity" href="_as_gen/dolfyn.Velocity.html" />
    <link rel="prev" title="Plotting Tools" href="plotting-tools.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="the-dlfn-api">
<h1><a class="toc-backref" href="#id1">The DOLfYN API</a><a class="headerlink" href="#the-dlfn-api" title="Permalink to this headline">¶</a></h1>
<p>This is the DOLfYN API. It is a high-level object-oriented library
composed of a set of <strong>data-object</strong> classes (types) that contain data
from a particular measurement instrument, and a collection of
<strong>functions</strong> that manipulate those data objects to accomplish data
processing and data analysis tasks.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-dlfn-api" id="id1">The DOLfYN API</a><ul>
<li><a class="reference internal" href="#dlfn-data-objects" id="id2">DOLfYN data objects</a></li>
<li><a class="reference internal" href="#dlfn-tools-and-functions" id="id3">DOLfYN tools and functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="dlfn-data-objects">
<h2><a class="toc-backref" href="#id2">DOLfYN data objects</a><a class="headerlink" href="#dlfn-data-objects" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.Velocity</span></code></a></td>
<td>This is the base class for velocity data objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dolfyn.ADPdata" title="dolfyn.ADPdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.ADPdata</span></code></a></td>
<td>The acoustic Doppler profiler (ADP) data type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dolfyn.ADVdata" title="dolfyn.ADVdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.ADVdata</span></code></a></td>
<td>The acoustic Doppler velocimeter (ADV) data type.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="dolfyn.Velocity">
<em class="property">class </em><code class="descclassname">dolfyn.</code><code class="descname">Velocity</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#Velocity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.Velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the base class for velocity data objects.</p>
<p>All ADP and ADV data objects inherit from this base class.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>DOLfYN Velocity objects are based on Python dicts, but have fancy
interactive printing properties and indexing properties.</p>
<p>First, the interactive printing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dolfyn</span> <span class="k">as</span> <span class="nn">dlfn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">dlfn</span><span class="o">.</span><span class="n">read_example</span><span class="p">(</span><span class="s1">&#39;BenchFile01.ad2cp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In an interactive interpreter, view the contents of the data
object by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span>
<span class="go">&lt;ADP data object&gt;</span>
<span class="go">. 9.11 minutes (started: Feb 24, 2017 10:01)</span>
<span class="go">. BEAM-frame</span>
<span class="go">. (38 bins, 1094 pings @ 2Hz)</span>
<span class="go">*------------</span>
<span class="go">| mpltime                  : &lt;time_array; (1094,); float64&gt;</span>
<span class="go">| range                    : &lt;array; (38,); float64&gt;</span>
<span class="go">| range_b5                 : &lt;array; (38,); float64&gt;</span>
<span class="go">| vel                      : &lt;array; (4, 38, 1094); float32&gt;</span>
<span class="go">| vel_b5                   : &lt;array; (1, 38, 1094); float32&gt;</span>
<span class="go">+ alt                      : + DATA GROUP</span>
<span class="go">+ altraw                   : + DATA GROUP</span>
<span class="go">+ config                   : + DATA GROUP</span>
<span class="go">+ env                      : + DATA GROUP</span>
<span class="go">+ orient                   : + DATA GROUP</span>
<span class="go">+ props                    : + DATA GROUP</span>
<span class="go">+ signal                   : + DATA GROUP</span>
<span class="go">+ sys                      : + DATA GROUP</span>
</pre></div>
</div>
<p>You can view the contents of a ‘DATA GROUP’ by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="p">[</span><span class="s1">&#39;env&#39;</span><span class="p">]</span>
<span class="go">&lt;class &#39;dolfyn.data.base.TimeData&#39;&gt;: Data Object with Keys:</span>
<span class="go">*------------</span>
<span class="go">| c_sound                  : &lt;array; (1094,); float32&gt;</span>
<span class="go">| press                    : &lt;array; (1094,); float32&gt;</span>
<span class="go">| temp                     : &lt;array; (1094,); float32&gt;</span>
</pre></div>
</div>
<p>Or you can also use attribute-style syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">signal</span>
<span class="go">&lt;class &#39;dolfyn.data.base.TimeData&#39;&gt;: Data Object with Keys:</span>
<span class="go">*------------</span>
<span class="go">| amp                      : &lt;array; (4, 38, 1094); float16&gt;</span>
<span class="go">| amp_b5                   : &lt;array; (1, 38, 1094); float16&gt;</span>
<span class="go">| corr                     : &lt;array; (4, 38, 1094); uint8&gt;</span>
<span class="go">| corr_b5                  : &lt;array; (1, 38, 1094); uint8&gt;</span>
</pre></div>
</div>
<p>You can directly access an item in a subgroup by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="p">[</span><span class="s1">&#39;env.c_sound&#39;</span><span class="p">]</span>
<span class="go">array([1520.9   , 1520.8501, 1520.8501, ..., 1522.3   , 1522.3   ,</span>
<span class="go">       1522.3   ], dtype=float32)</span>
</pre></div>
</div>
<p># And you can test for the presence of a variable by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;signal.amp&#39;</span> <span class="ow">in</span> <span class="n">dat</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="dolfyn.Velocity.U">
<code class="descname">U</code><a class="headerlink" href="#dolfyn.Velocity.U" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontal velocity as a complex quantity.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.U_angle">
<code class="descname">U_angle</code><a class="headerlink" href="#dolfyn.Velocity.U_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle of horizontal velocity vector (radians clockwise from
east/X/streamwise).</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.U_mag">
<code class="descname">U_mag</code><a class="headerlink" href="#dolfyn.Velocity.U_mag" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontal velocity magnitude.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Join two data objects together.</p>
<p>For example, two data objects <code class="docutils literal notranslate"><span class="pre">d1</span></code> and <code class="docutils literal notranslate"><span class="pre">d2</span></code> (which must
contain the same variables, with the same array dimensions)
can be joined together by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the data object.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>$self</em>, <em>key</em>, <em>default=None</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value for key if key is in the dictionary, else default.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.iter_data">
<code class="descname">iter_data</code><span class="sig-paren">(</span><em>include_hidden=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.iter_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the keys for all data items in this data object,
including walking through sub-data objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>include_hidden</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (Default: False)</span></dt>
<dd><p class="first last">Whether entries starting with ‘_’ should be included in
the iteration.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.iter_subgroups">
<code class="descname">iter_subgroups</code><span class="sig-paren">(</span><em>include_hidden=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.iter_subgroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the keys for all sub-groups in this data object,
including walking through sub-groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>include_hidden</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (Default: False)</span></dt>
<dd><p class="first last">Whether entries starting with ‘_’ should be included in
the iteration.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's keys<a class="headerlink" href="#dolfyn.Velocity.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.n_time">
<code class="descname">n_time</code><a class="headerlink" href="#dolfyn.Velocity.n_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of timesteps in the data object.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#dolfyn.Velocity.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.rotate2">
<code class="descname">rotate2</code><span class="sig-paren">(</span><em>out_frame</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#Velocity.rotate2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.Velocity.rotate2" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the data object into a new coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>out_frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {‘beam’, ‘inst’, ‘earth’, ‘principal’}</span></dt>
<dd><p class="first last">The coordinate system to rotate the data into.</p>
</dd>
<dt><strong>inplace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Operate on self (True), or return a copy that
has been rotated (False, default).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objout</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></dt>
<dd><p class="first last">The rotated data object. This is <cite>self</cite> if inplace is True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dolfyn.rotate2" title="dolfyn.rotate2"><code class="xref py py-func docutils literal notranslate"><span class="pre">dolfyn.rotate2()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.set_declination">
<code class="descname">set_declination</code><span class="sig-paren">(</span><em>declination</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#Velocity.set_declination"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.Velocity.set_declination" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the declination of the data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>declination</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The value of the magnetic declination in degrees (positive
values specify that Magnetic North is clockwise from True North)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method modifies the data object in the following ways:</p>
<ul class="simple">
<li>If the data-object is in the <em>earth</em> reference frame at the time of
setting declination, it will be rotated into the “<em>True-East</em>,
<em>True-North</em>, Up” (hereafter, ETU) coordinate system</li>
<li><code class="docutils literal notranslate"><span class="pre">dat['orient']['orientmat']</span></code> is modified to be an ETU to
instrument (XYZ) rotation matrix (rather than the magnetic-ENU to
XYZ rotation matrix). Therefore, all rotations to/from the ‘earth’
frame will now be to/from this ETU coordinate system.</li>
<li>The value of the specified declination will be stored in
<code class="docutils literal notranslate"><span class="pre">dat.props['declination']</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">dat['orient']['heading']</span></code> is adjusted for declination
(i.e., it is relative to True North).</li>
<li>If <code class="docutils literal notranslate"><span class="pre">dat['props']['principal_heading']</span></code> is set, it is
adjusted to account for the orientation of the new ‘True’
earth coordinate system (i.e., calling set_declination on a
data object in the principal coordinate system, then calling
dat.rotate2(‘earth’) will yield a data object in the new
‘True’ earth coordinate system)</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.shape">
<code class="descname">shape</code><a class="headerlink" href="#dolfyn.Velocity.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of ‘scalar’ data in this data object.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.subset">
<code class="descname">subset</code><a class="headerlink" href="#dolfyn.Velocity.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Subset is an <cite>indexer</cite> for creating subsets of the data
object using Python slice syntax.</p>
<p>For example, you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dat2</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">subset</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">500</span><span class="p">]</span>
</pre></div>
</div>
<p>Which returns a new data object that contains the 10th through
500th entry for each variable in the data object. This also
operates recursively through sub-objects.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.Velocity.to_hdf5">
<code class="descname">to_hdf5</code><span class="sig-paren">(</span><em>buf</em>, <em>chunks=True</em>, <em>compression='gzip'</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.Velocity.to_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the data in this object to an hdf5 file.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.u">
<code class="descname">u</code><a class="headerlink" href="#dolfyn.Velocity.u" title="Permalink to this definition">¶</a></dt>
<dd><p>The first velocity component.</p>
<p>This is simply a shortcut to self[‘vel’][0]. Therefore,
depending on the coordinate system of the data object
(self[‘props’][‘coord_sys’]), it is:</p>
<ul class="simple">
<li>beam:      beam1</li>
<li>inst:      x</li>
<li>earth:     east</li>
<li>principal: streamwise</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.v">
<code class="descname">v</code><a class="headerlink" href="#dolfyn.Velocity.v" title="Permalink to this definition">¶</a></dt>
<dd><p>The second velocity component.</p>
<p>This is simply a shortcut to self[‘vel’][1]. Therefore,
depending on the coordinate system of the data object
(self[‘props’][‘coord_sys’]), it is:</p>
<ul class="simple">
<li>beam:      beam2</li>
<li>inst:      y</li>
<li>earth:     north</li>
<li>principal: cross-stream</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.Velocity.w">
<code class="descname">w</code><a class="headerlink" href="#dolfyn.Velocity.w" title="Permalink to this definition">¶</a></dt>
<dd><p>The third velocity component.</p>
<p>This is simply a shortcut to self[‘vel’][2]. Therefore,
depending on the coordinate system of the data object
(self[‘props’][‘coord_sys’]), it is:</p>
<ul class="simple">
<li>beam:      beam3</li>
<li>inst:      z</li>
<li>earth:     up</li>
<li>principal: up</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dolfyn.ADPdata">
<em class="property">class </em><code class="descclassname">dolfyn.</code><code class="descname">ADPdata</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adp/base.html#ADPdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.ADPdata" title="Permalink to this definition">¶</a></dt>
<dd><p>The acoustic Doppler profiler (ADP) data type.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">dolfyn.Velocity</span></code></a></p>
</div>
<dl class="attribute">
<dt id="dolfyn.ADPdata.S2">
<code class="descname">S2</code><a class="headerlink" href="#dolfyn.ADPdata.S2" title="Permalink to this definition">¶</a></dt>
<dd><p>The horizontal shear-squared.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dolfyn.ADPdata.dvdz" title="dolfyn.ADPdata.dvdz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dvdz()</span></code></a>, <a class="reference internal" href="#dolfyn.ADPdata.dudz" title="dolfyn.ADPdata.dudz"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dudz()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This is actually (dudz)^2 + (dvdz)^2. So, if those variables
are not actually vertical derivatives of the horizontal
velocity, then this is not the ‘horizontal shear-squared’.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.ADPdata.dudz">
<code class="descname">dudz</code><a class="headerlink" href="#dolfyn.ADPdata.dudz" title="Permalink to this definition">¶</a></dt>
<dd><p>The shear in the first velocity component.</p>
<p class="rubric">Notes</p>
<p>The derivative direction is along the profiler’s ‘z’
coordinate (‘dz’ is actually diff(self[‘range’])), not necessarily the
‘true vertical’ direction.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.ADPdata.dvdz">
<code class="descname">dvdz</code><a class="headerlink" href="#dolfyn.ADPdata.dvdz" title="Permalink to this definition">¶</a></dt>
<dd><p>The shear in the second velocity component.</p>
<p class="rubric">Notes</p>
<p>The derivative direction is along the profiler’s ‘z’
coordinate (‘dz’ is actually diff(self[‘range’])), not necessarily the
‘true vertical’ direction.</p>
</dd></dl>

<dl class="attribute">
<dt id="dolfyn.ADPdata.dwdz">
<code class="descname">dwdz</code><a class="headerlink" href="#dolfyn.ADPdata.dwdz" title="Permalink to this definition">¶</a></dt>
<dd><p>The shear in the third velocity component.</p>
<p class="rubric">Notes</p>
<p>The derivative direction is along the profiler’s ‘z’
coordinate (‘dz’ is actually diff(self[‘range’])), not necessarily the
‘true vertical’ direction.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dolfyn.ADVdata">
<em class="property">class </em><code class="descclassname">dolfyn.</code><code class="descname">ADVdata</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/base.html#ADVdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.ADVdata" title="Permalink to this definition">¶</a></dt>
<dd><p>The acoustic Doppler velocimeter (ADV) data type.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">dolfyn.Velocity</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="dlfn-tools-and-functions">
<h2><a class="toc-backref" href="#id3">DOLfYN tools and functions</a><a class="headerlink" href="#dlfn-tools-and-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dolfyn.read" title="dolfyn.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.read</span></code></a></td>
<td>Read a binary Nortek (e.g., .VEC, .wpr, .ad2cp, etc.) or RDI (.000, .PD0, etc.) data file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dolfyn.rotate2" title="dolfyn.rotate2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.rotate2</span></code></a></td>
<td>Rotate a data object to a new coordinate system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dolfyn.adv.motion.CorrectMotion" title="dolfyn.adv.motion.CorrectMotion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.adv.motion.CorrectMotion</span></code></a></td>
<td>This object performs motion correction on an IMU-ADV data object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dolfyn.VelBinner" title="dolfyn.VelBinner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.VelBinner</span></code></a></td>
<td>This is the base binning (averaging) tool.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dolfyn.adv.turbulence.TurbBinner" title="dolfyn.adv.turbulence.TurbBinner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.adv.turbulence.TurbBinner</span></code></a></td>
<td>Computes various averages and turbulence statistics from cleaned ADV data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dolfyn.calc_principal_heading" title="dolfyn.calc_principal_heading"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dolfyn.calc_principal_heading</span></code></a></td>
<td>Compute the principal angle of the horizontal velocity.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="dolfyn.read">
<code class="descclassname">dolfyn.</code><code class="descname">read</code><span class="sig-paren">(</span><em>fname</em>, <em>userdata=True</em>, <em>nens=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/io/api.html#read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a binary Nortek (e.g., .VEC, .wpr, .ad2cp, etc.) or RDI
(.000, .PD0, etc.) data file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Filename of Nortek file to read.</p>
</dd>
<dt><strong>userdata</strong> <span class="classifier-delimiter">:</span> <span class="classifier">True, False, or string of userdata.json filename</span></dt>
<dd><p class="first last">(default <code class="docutils literal notranslate"><span class="pre">True</span></code>) Whether to read the
‘&lt;base-filename&gt;.userdata.json’ file.</p>
</dd>
<dt><strong>nens</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None (default: read entire file), int, or</span></dt>
<dd><dl class="first last docutils">
<dt>2-element tuple (start, stop)</dt>
<dd><p class="first last">Number of pings to read from the file</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">&lt;~dolfyn.data.velocity.Velocity&gt;</span></code></span></dt>
<dd><p class="first last">A DOLfYN velocity data object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="dolfyn.rotate2">
<code class="descclassname">dolfyn.</code><code class="descname">rotate2</code><span class="sig-paren">(</span><em>obj</em>, <em>out_frame='earth'</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/rotate/main.html#rotate2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.rotate2" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a data object to a new coordinate system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></dt>
<dd><p class="first last">The dolfyn velocity-data (ADV or ADP) object to rotate.</p>
</dd>
<dt><strong>out_frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {‘beam’, ‘inst’, ‘earth’, ‘principal’}</span></dt>
<dd><p class="first last">The coordinate system to rotate the data into.</p>
</dd>
<dt><strong>inplace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Operate on the input data object (True), or return a copy that
has been rotated (False, default).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>objout</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#dolfyn.Velocity" title="dolfyn.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></dt>
<dd><p class="first last">The rotated data object. Note that when <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>, the
input object is modified in-place <em>and</em> returned (i.e.,
<code class="docutils literal notranslate"><span class="pre">objout</span></code> is <code class="docutils literal notranslate"><span class="pre">obj</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function rotates all variables in <code class="docutils literal notranslate"><span class="pre">obj.props['rotate_vars']</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="dolfyn.adv.motion.CorrectMotion">
<em class="property">class </em><code class="descclassname">dolfyn.adv.motion.</code><code class="descname">CorrectMotion</code><span class="sig-paren">(</span><em>accel_filtfreq=None</em>, <em>vel_filtfreq=None</em>, <em>separate_probes=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/motion.html#CorrectMotion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.motion.CorrectMotion" title="Permalink to this definition">¶</a></dt>
<dd><p>This object performs motion correction on an IMU-ADV data
object. The IMU and ADV data should be tightly synchronized and
contained in a single data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>accel_filtfreq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the frequency at which to high-pass filter the acceleration
signal to remove low-frequency drift.</p>
</dd>
<dt><strong>vel_filtfreq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">a second frequency to high-pass filter the integrated
acceleration.  (default: 1/3 of accel_filtfreq)</p>
</dd>
<dt><strong>separate_probes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (optional: False)</span></dt>
<dd><p class="first last">a flag to perform motion-correction at the probe tips, and
perform motion correction in beam-coordinates, then transform
back into XYZ/earth coordinates. This correction seems to be
lower than the noise levels of the ADV, so the defualt is to not
use it (False).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Acceleration signals from inertial sensors are notorious for
having a small bias that can drift slowly in time. When
integrating these signals to estimate velocity the bias is
amplified and leads to large errors in the estimated
velocity. There are two methods for removing these errors,</p>
<ol class="arabic simple">
<li>high-pass filter the acceleration signal prior and/or after
integrating. This implicitly assumes that the low-frequency
translational velocity is zero.</li>
<li>provide a slowly-varying reference position (often from a GPS)
to an IMU that can use the signal (usually using Kalman
filters) to debias the acceleration signal.</li>
</ol>
<p>Because method (1) removes <cite>real</cite> low-frequency acceleration,
method (2) is more accurate. However, providing reference position
estimates to undersea instruments is practically challenging and
expensive. Therefore, lacking the ability to use method (2), this
function utilizes method (1).</p>
<p>For deployments in which the ADV is mounted on a mooring, or other
semi-fixed structure, the assumption of zero low-frequency
translational velocity is a reasonable one. However, for
deployments on ships, gliders, or other moving objects it is
not. The measured velocity, after motion-correction, will still
hold some of this contamination and will be a sum of the ADV
motion and the measured velocity on long time scales.  If
low-frequency motion is known separate from the ADV (e.g. from a
bottom-tracking ADP, or from a ship’s GPS), it may be possible to
remove that signal from the ADV signal in post-processing. The
accuracy of this approach has not, to my knowledge, been tested
yet.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dolfyn.adv</span> <span class="kn">import</span> <span class="n">api</span> <span class="k">as</span> <span class="n">avm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">avm</span><span class="o">.</span><span class="n">read_nortek</span><span class="p">(</span><span class="s1">&#39;my_data_file.vec&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">avm</span><span class="o">.</span><span class="n">CorrectMotion</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corrected_data</span> <span class="o">=</span> <span class="n">mc</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="dolfyn.adv.motion.CorrectMotion.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>advo</em>, <em>to_earth=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/motion.html#CorrectMotion.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.motion.CorrectMotion.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform motion correction on an IMU-equipped ADV object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>advo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ADVdata</span></code></span></dt>
<dd><p class="first">The adv object on which to perform motion correction.
It must contain the following data attributes:</p>
<ul class="last simple">
<li>vel : The velocity array.</li>
<li>accel : The translational acceleration array.</li>
<li>angrt : The rotation-rate array.</li>
<li>orientmat : The orientation matrix.</li>
<li>props : a dictionary that has ‘body2head_vec’,
‘body2head_rotmat’ and ‘coord_sys’.</li>
</ul>
</dd>
<dt><strong>to_earth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (optional, default: True)</span></dt>
<dd><p class="first last">A boolean that specifies whether the data should be
rotated into the earth frame.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>After calling this function, <cite>advo</cite> will have <em>velrot</em> and
<em>velacc</em> data attributes. The velocity vector attribute <code class="docutils literal notranslate"><span class="pre">vel</span></code>
will be motion corrected according to:</p>
<blockquote>
<div>u_corr = u_raw + velacc + velrot</div></blockquote>
<p>Therefore, to recover the ‘raw’ velocity, subtract velacc and
velrot from <code class="docutils literal notranslate"><span class="pre">vel</span></code>.</p>
<p>This method does not return a data object, it operates on
(motion corrects) the input <cite>advo</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dolfyn.VelBinner">
<em class="property">class </em><code class="descclassname">dolfyn.</code><code class="descname">VelBinner</code><span class="sig-paren">(</span><em>n_bin</em>, <em>fs</em>, <em>n_fft=None</em>, <em>n_fft_coh=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#VelBinner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.VelBinner" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the base binning (averaging) tool.</p>
<p>All DOLfYN binning tools derive from this base class.</p>
<p class="rubric">Examples</p>
<p>The VelBinner class is used to compute averages and turbulence
statistics from ‘raw’ (unaveraged) ADV or ADP measurements, for
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># First read or load some data.</span>
<span class="n">rawdat</span> <span class="o">=</span> <span class="n">dlfn</span><span class="o">.</span><span class="n">read_example</span><span class="p">(</span><span class="s1">&#39;BenchFile01.ad2cp&#39;</span><span class="p">)</span>

<span class="c1"># Now initialize the averaging tool:</span>
<span class="n">binner</span> <span class="o">=</span> <span class="n">dlfn</span><span class="o">.</span><span class="n">VelBinner</span><span class="p">(</span><span class="n">n_bin</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">rawdat</span><span class="p">[</span><span class="s1">&#39;props&#39;</span><span class="p">][</span><span class="s1">&#39;fs&#39;</span><span class="p">])</span>

<span class="c1"># This computes the basic averages</span>
<span class="n">avg</span> <span class="o">=</span> <span class="n">binner</span><span class="p">(</span><span class="n">rawdat</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="dolfyn.VelBinner.calc_acov">
<code class="descname">calc_acov</code><span class="sig-paren">(</span><em>indat</em>, <em>n_bin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.calc_acov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the auto-covariance of the raw-signal <cite>indat</cite>.</p>
<p>As opposed to calc_xcov, which returns the full
cross-covariance between two arrays, this function only
returns a quarter of the full auto-covariance. It computes the
auto-covariance over half of the range, then averages the two
sides (to return a ‘quartered’ covariance).</p>
<p>This has the advantage that the 0 index is actually zero-lag.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_omega">
<code class="descname">calc_omega</code><span class="sig-paren">(</span><em>fs=None</em>, <em>coh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.calc_omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the radial-frequency vector for the psd’s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">The sample rate (Hz).</p>
</dd>
<dt><strong>coh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Calculate the frequency vector for coherence/cross-spectra
(default: False) i.e. use self.n_fft_coh instead of
self.n_fft.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_stress">
<code class="descname">calc_stress</code><span class="sig-paren">(</span><em>veldat</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#VelBinner.calc_stress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.VelBinner.calc_stress" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the stresses (cross-covariances of u,v,w).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>veldat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a velocity data array. The last dimension is assumed</span></dt>
<dd><p class="first last">to be time.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">An array of stress values.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_tke">
<code class="descname">calc_tke</code><span class="sig-paren">(</span><em>veldat, noise=[0, 0, 0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#VelBinner.calc_tke"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.VelBinner.calc_tke" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the tke (variances of u,v,w).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>veldat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a velocity data array. The last dimension is assumed</span></dt>
<dd><p class="first last">to be time.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a three-element vector of the noise levels of the</span></dt>
<dd><p class="first last">velocity data for ach component of velocity.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">An array of tke values.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_vel_cpsd">
<code class="descname">calc_vel_cpsd</code><span class="sig-paren">(</span><em>veldat</em>, <em>rotate_u=False</em>, <em>fs=None</em>, <em>window='hann'</em>, <em>n_bin=None</em>, <em>n_fft=None</em>, <em>n_pad=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#VelBinner.calc_vel_cpsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.VelBinner.calc_vel_cpsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross-spectra of velocity components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>veldat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The raw velocity data.</p>
</dd>
<dt><strong>rotate_u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (optional)</span></dt>
<dd><p class="first last">If True, each ‘bin’ of horizontal velocity is rotated into
its principal axis prior to calculating the psd.  (default:
False).</p>
</dd>
<dt><strong>fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">The sample rate (default: from the binner).</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or array</span></dt>
<dd><p class="first last">Specify the window function.</p>
</dd>
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The bin-size (default: from the binner).</p>
</dd>
<dt><strong>n_fft</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The fft size (default: from the binner).</p>
</dd>
<dt><strong>n_pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The number of values to pad with zero (default: 0)</p>
</dd>
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">Controls amount of overlap in fft (default: the step size is
chosen to maximize data use, minimize nens, and have a
minimum of 50% overlap.).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>CSpec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (3, M, N_FFT)</span></dt>
<dd><p class="first last">The first-dimension of the cross-spectrum is the three
different cross-spectra: ‘uv’, ‘uw’, ‘vw’ (in that order).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_vel_psd">
<code class="descname">calc_vel_psd</code><span class="sig-paren">(</span><em>veldat, rotate_u=False, fs=None, window='hann', noise=[0, 0, 0], n_bin=None, n_fft=None, n_pad=None, step=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/data/velocity.html#VelBinner.calc_vel_psd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.VelBinner.calc_vel_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the psd of velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>veldat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The raw velocity data.</p>
</dd>
<dt><strong>rotate_u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (optional)</span></dt>
<dd><p class="first last">If True, each ‘bin’ of horizontal velocity is rotated into
its principal axis prior to calculating the psd.  (default:
False).</p>
</dd>
<dt><strong>fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (optional)</span></dt>
<dd><p class="first last">The sample rate (default: from the binner).</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or array</span></dt>
<dd><p class="first last">Specify the window function.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list(3 floats) (optional)</span></dt>
<dd><p class="first last">Noise level of each component’s velocity measurement
(default 0).</p>
</dd>
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The bin-size (default: from the binner).</p>
</dd>
<dt><strong>n_fft</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The fft size (default: from the binner).</p>
</dd>
<dt><strong>n_pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">The number of values to pad with zero (default: 0)</p>
</dd>
<dt><strong>step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd><p class="first last">Controls amount of overlap in fft (default: the step size is
chosen to maximize data use, minimize nens, and have a
minimum of 50% overlap.).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (3, M, N_FFT)</span></dt>
<dd><p class="first last">The first-dimension of the spectrum is the three
different spectra: ‘uu’, ‘vv’, ‘ww’.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.calc_xcov">
<code class="descname">calc_xcov</code><span class="sig-paren">(</span><em>indt1</em>, <em>indt2</em>, <em>npt=None</em>, <em>n_bin1=None</em>, <em>n_bin2=None</em>, <em>normed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.calc_xcov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cross-covariance between arrays indt1 and indt2
for each bin.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.cohere">
<code class="descname">cohere</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>window='hann'</em>, <em>debias=True</em>, <em>noise=(0</em>, <em>0)</em>, <em>n_fft=None</em>, <em>n_bin1=None</em>, <em>n_bin2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.cohere" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate coherence between <cite>dat1</cite> and <cite>dat2</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.cpsd">
<code class="descname">cpsd</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>fs=None</em>, <em>window='hann'</em>, <em>n_fft=None</em>, <em>n_bin1=None</em>, <em>n_bin2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.cpsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the ‘cross power spectral density’ of <cite>dat</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The first raw-data array of which to calculate the cpsd.</p>
</dd>
<dt><strong>dat2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The second raw-data array of which to calculate the cpsd.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">String indicating the window function to use (default: ‘hanning’).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The cross-spectral density of <cite>dat1</cite> and <cite>dat2</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.demean">
<code class="descname">demean</code><span class="sig-paren">(</span><em>dat</em>, <em>n_pad=0</em>, <em>n_bin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.demean" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the array <cite>dat</cite> and remove the mean from each ensemble.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.detrend">
<code class="descname">detrend</code><span class="sig-paren">(</span><em>dat</em>, <em>n_pad=0</em>, <em>n_bin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the array <cite>dat</cite> and remove the best-fit trend line.</p>
<p>… Need to fix this to deal with NaNs…</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.do_avg">
<code class="descname">do_avg</code><span class="sig-paren">(</span><em>rawdat</em>, <em>outdat=None</em>, <em>names=None</em>, <em>n_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.do_avg" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rawdat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">raw_data_object</span></dt>
<dd><p class="first last">The raw data structure to be binned</p>
</dd>
<dt><strong>outdat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">avg_data_object</span></dt>
<dd><p class="first last">The bin’d (output) data object to which averaged data is added.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">The names of variables to be averaged.  If <cite>names</cite> is None,
all data in <cite>rawdat</cite> will be binned.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.do_var">
<code class="descname">do_var</code><span class="sig-paren">(</span><em>rawdat</em>, <em>outdat=None</em>, <em>names=None</em>, <em>suffix='_var'</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.do_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the variance of data attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rawdat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">raw_data_object</span></dt>
<dd><p class="first last">The raw data structure to be binned.</p>
</dd>
<dt><strong>outdat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">avg_data_object</span></dt>
<dd><p class="first last">The bin’d (output) data object to which variance data is added.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">The names of variables of which to calculate variance.  If
<cite>names</cite> is None, all data in <cite>rawdat</cite> will be binned.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>dat</em>, <em>axis=-1</em>, <em>n_bin=None</em>, <em>mask_thresh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Average an array object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default is self.n_bin)</span></dt>
<dd></dd>
<dt><strong>mask_thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (between 0 and 1)</span></dt>
<dd><p class="first last">if the input data is a masked array, and mask_thresh is
not None mask the averaged values where the fraction of
bad points is greater than mask_thresh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.mean_angle">
<code class="descname">mean_angle</code><span class="sig-paren">(</span><em>dat</em>, <em>axis=-1</em>, <em>units='radians'</em>, <em>n_bin=None</em>, <em>mask_thresh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.mean_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Average an angle array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘radians’ | ‘degrees’}</span></dt>
<dd></dd>
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default is self.n_bin)</span></dt>
<dd></dd>
<dt><strong>mask_thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (between 0 and 1)</span></dt>
<dd><p class="first last">if the input data is a masked array, and mask_thresh is
not None mask the averaged values where the fraction of
bad points is greater than mask_thresh</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.phase_angle">
<code class="descname">phase_angle</code><span class="sig-paren">(</span><em>dat1</em>, <em>dat2</em>, <em>window='hann'</em>, <em>n_fft=None</em>, <em>n_bin1=None</em>, <em>n_bin2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.phase_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the phase difference between two signals as a
function of frequency (complimentary to coherence).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dat1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The first raw-data array of which to calculate the cpsd.</p>
</dd>
<dt><strong>dat2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The second raw-data array of which to calculate the cpsd.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">String indicating the window function to use (default: ‘hanning’).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The phase difference between signal dat1 and dat2.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.psd">
<code class="descname">psd</code><span class="sig-paren">(</span><em>dat</em>, <em>fs=None</em>, <em>window='hann'</em>, <em>noise=0</em>, <em>n_bin=None</em>, <em>n_fft=None</em>, <em>step=None</em>, <em>n_pad=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ‘power spectral density’ of <cite>dat</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">data_object</span></dt>
<dd><p class="first last">The raw-data array of which to calculate the psd.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">String indicating the window function to use (default: ‘hanning’).</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The white-noise level of the measurement (in the same units
as <cite>dat</cite>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.VelBinner.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>arr</em>, <em>n_pad=0</em>, <em>n_bin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dolfyn.VelBinner.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the array <cite>arr</cite> to shape (…,n,n_bin+n_pad).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>arr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd></dd>
<dt><strong>n_pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Is used to add <cite>n_pad</cite>/2 points from the end of the previous
ensemble to the top of the current, and <cite>n_pad</cite>/2 points
from the top of the next ensemble to the bottom of the
current.  Zeros are padded in the upper-left and lower-right
corners of the matrix (beginning/end of timeseries).  In
this case, the array shape will be (…,`n`,`n_pad`+`n_bin`)</p>
</dd>
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, int (optional)</span></dt>
<dd><p class="first last">Override this binner’s n_bin.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>n_bin</cite> can be non-integer, in which case the output array
size will be <cite>n_pad`+`n_bin</cite>, and the decimal will
cause skipping of some data points in <cite>arr</cite>.  In particular,
every mod(<cite>n_bin</cite>,1) bins will have a skipped point. For
example:
- for n_bin=2048.2 every 1/5 bins will have a skipped point.
- for n_bin=4096.9 every 9/10 bins will have a skipped point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dolfyn.adv.turbulence.TurbBinner">
<em class="property">class </em><code class="descclassname">dolfyn.adv.turbulence.</code><code class="descname">TurbBinner</code><span class="sig-paren">(</span><em>n_bin</em>, <em>fs</em>, <em>n_fft=None</em>, <em>n_fft_coh=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes various averages and turbulence statistics from cleaned
ADV data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_bin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The length of <cite>bin</cite> s, in number of points, for this averaging
operator.</p>
</dd>
<dt><strong>n_fft</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (optional, default: n_fft = n_bin)</span></dt>
<dd><p class="first last">The length of the FFT for computing spectra (must be &lt; n_bin)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>advr, out_type=None, omega_range_epsilon=[6.28, 12.57], Itke_thresh=0, window='hann'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a suite of turbulence statistics for the input data
advr, and return a <cite>binned</cite> data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>advr</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ADVdata</span></code></span></dt>
<dd><p class="first last">The raw adv data-object to <cite>bin</cite>, average and compute
turbulence statistics of.</p>
</dd>
<dt><strong>omega_range_epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable(2)</span></dt>
<dd><p class="first last">The frequency range (low, high) over which to estimate the
dissipation rate <cite>epsilon</cite> [rad/s].</p>
</dd>
<dt><strong>Itke_thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">The threshold for velocity magnitude for</span></dt>
<dd><p class="first last">computing the turbulence intensity. Values of Itke where
U_mag &lt; Itke_thresh are set to NaN.  (default: 0).</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1, None, ‘hann’</span></dt>
<dd><p class="first last">The window to use for psds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>advb</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.ADVbinned</span></code></span></dt>
<dd><p class="first">Returns an ‘binned’ (i.e. ‘averaged’) data object. All
fields of the input data object are averaged in n_bin
chunks. This object also computes the following items over
those chunks:</p>
<ul class="last">
<li><p class="first">tke_vec : The energy in each component (components are also
accessible as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">upup_</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">vpvp_</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">wpwp_</span></code>)</p>
</li>
<li><p class="first">stress : The Reynolds stresses (each component is
accessible as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">upwp_</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">vpwp_</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">upvp_</span></code>)</p>
</li>
<li><p class="first">sigma_Uh : The standard deviation of the horizontal
velocity.</p>
</li>
<li><p class="first">Spec : A data group containing the spectra of the velocity
in radial frequency units. The data group contains:</p>
<blockquote>
<div><ul class="simple">
<li>vel : the velocity spectra array (m^2/s/radian))</li>
<li>omega : the radial frequncy (radian / s)</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.calc_Lint">
<code class="descname">calc_Lint</code><span class="sig-paren">(</span><em>corr_vel</em>, <em>U_mag</em>, <em>fs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.calc_Lint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.calc_Lint" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate integral length scales.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>corr_vel</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt>
<dd><p class="first last">The auto-covariance array (i.e. computed using calc_acov).</p>
</dd>
<dt><strong>U_mag</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time)</span></dt>
<dd><p class="first last">The velocity magnitude for this bin.</p>
</dd>
<dt><strong>fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The raw sample rate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Lint</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time)</span></dt>
<dd><p class="first last">The integral length scale (Tint*U_mag).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The integral time scale (Tint) is the lag-time at which the
auto-covariance falls to 1/e.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.calc_epsilon_LT83">
<code class="descname">calc_epsilon_LT83</code><span class="sig-paren">(</span><em>spec, omega, U_mag, omega_range=[6.28, 12.57]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.calc_epsilon_LT83"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.calc_epsilon_LT83" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the dissipation rate from the spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…,n_time,n_f)</span></dt>
<dd><p class="first last">The spectrum array [m^2/s/radian]</p>
</dd>
<dt><strong>omega</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (n_f)</span></dt>
<dd><p class="first last">The frequency array [rad/s]</p>
</dd>
<dt><strong>U_mag</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…,n_time)</span></dt>
<dd><p class="first last">The velocity magnitude [m/s]</p>
</dd>
<dt><strong>omega_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable(2)</span></dt>
<dd><p class="first last">The range over which to integrate/average the spectrum.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (…,n_time)</span></dt>
<dd><p class="first last">The dissipation rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This uses the <cite>standard</cite> formula for dissipation:</p>
<div class="math notranslate nohighlight">
\[S(k) = \alpha \epsilon^{2/3} k^{-5/3}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha = 0.5\)</span> (1.5 for all three velocity
components), <cite>k</cite> is wavenumber and <cite>S(k)</cite> is the turbulent
kinetic energy spectrum.</p>
<p>With <span class="math notranslate nohighlight">\(k \rightarrow \omega / U\)</span> then–to preserve variance–
<span class="math notranslate nohighlight">\(S(k) = U S(\omega)\)</span> and so this becomes:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \alpha \epsilon^{2/3} \omega^{-5/3} U^{2/3}\]</div>
<p>LT83 : Lumley and Terray “Kinematics of turbulence convected
by a random wave field” JPO, 1983, 13, 2000-2007.</p>
</dd></dl>

<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.calc_epsilon_SF">
<code class="descname">calc_epsilon_SF</code><span class="sig-paren">(</span><em>veldat, umag, fs=None, freq_rng=[0.5, 5.0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.calc_epsilon_SF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.calc_epsilon_SF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate epsilon using the “structure function” (SF) method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>veldat</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time, n_bin)</span></dt>
<dd><p class="first last">The raw velocity signal (last dimension time) upon which to
perform the SF technique.</p>
</dd>
<dt><strong>umag</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time)</span></dt>
<dd><p class="first last">The bin-averaged horizontal velocity magnitude.</p>
</dd>
<dt><strong>fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The sample rate of <cite>veldat</cite> [hz].</p>
</dd>
<dt><strong>freq_rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable(2)</span></dt>
<dd><p class="first last">The frequency range over which to compute the SF [hz].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time)</span></dt>
<dd><p class="first last">The dissipation rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.calc_epsilon_TE01">
<code class="descname">calc_epsilon_TE01</code><span class="sig-paren">(</span><em>advbin, advraw, omega_range=[6.28, 12.57]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.calc_epsilon_TE01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.calc_epsilon_TE01" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the dissipation according to TE01.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>advbin</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ADVbinned</span></code></span></dt>
<dd><p class="first last">The binned adv object. The following spectra and basic
turbulence statistics must already be computed.</p>
</dd>
<dt><strong>advraw</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ADVdata</span></code></span></dt>
<dd><p class="first last">The raw adv object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>TE01 <span class="classifier-delimiter">:</span> <span class="classifier">Trowbridge, J and Elgar, S, “Turbulence measurements in</span></dt>
<dd>the Surf Zone” JPO, 2001, 31, 2403-2417.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dolfyn.adv.turbulence.TurbBinner.up_angle">
<code class="descname">up_angle</code><span class="sig-paren">(</span><em>Uh_complex</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/adv/turbulence.html#TurbBinner.up_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.adv.turbulence.TurbBinner.up_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the angle of the turbulence fluctuations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Uh_complex</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time * n_bin)</span></dt>
<dd><p class="first last">The complex, raw horizontal velocity (non-binned).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (…, n_time)</span></dt>
<dd><p class="first last">The angle of the turbulence [rad]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dolfyn.calc_principal_heading">
<code class="descclassname">dolfyn.</code><code class="descname">calc_principal_heading</code><span class="sig-paren">(</span><em>vel</em>, <em>tidal_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dolfyn/rotate/base.html#calc_principal_heading"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dolfyn.calc_principal_heading" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the principal angle of the horizontal velocity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray (2,…,Nt), or (3,…,Nt)</span></dt>
<dd><p class="first last">The 2D or 3D velocity array (3rd-dim is ignored in this calculation)</p>
</dd>
<dt><strong>tidal_mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (default: True)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>p_heading</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or ndarray</span></dt>
<dd><p class="first last">The principal heading(s) in degrees clockwise from North.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The tidal mode follows these steps:</dt>
<dd><ol class="first last arabic simple">
<li>rotates vectors with negative v by 180 degrees</li>
<li>then doubles those angles to make a complete circle again</li>
<li>computes a mean direction from this, and halves that angle again.</li>
<li>The returned angle is forced to be between 0 and 180. So, you
may need to add 180 to this if you want your positive
direction to be in the western-half of the plane.</li>
</ol>
</dd>
</dl>
<p>Otherwise, this function simply compute the average direction
using a vector method.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">DOLfYN</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Download and Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">The Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-structure.html">Data Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotations.html">Rotations and Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="motion-correction.html">Motion Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting-tools.html">Plotting Tools</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The DOLfYN API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dlfn-data-objects">DOLfYN data objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.Velocity.html">dolfyn.Velocity</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.ADPdata.html">dolfyn.ADPdata</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.ADVdata.html">dolfyn.ADVdata</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dlfn-tools-and-functions">DOLfYN tools and functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.read.html">dolfyn.read</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.rotate2.html">dolfyn.rotate2</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.adv.motion.CorrectMotion.html">dolfyn.adv.motion.CorrectMotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.VelBinner.html">dolfyn.VelBinner</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.adv.turbulence.TurbBinner.html">dolfyn.adv.turbulence.TurbBinner</a></li>
<li class="toctree-l3"><a class="reference internal" href="_as_gen/dolfyn.calc_principal_heading.html">dolfyn.calc_principal_heading</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="plotting-tools.html" title="previous chapter">Plotting Tools</a></li>
      <li>Next: <a href="_as_gen/dolfyn.Velocity.html" title="next chapter">dolfyn.Velocity</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Levi Kilcher.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>